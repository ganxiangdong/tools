package main

import (
	"flag"
	"fmt"
	"github.com/fatih/color"
	"go/ast"
	"go/parser"
	"go/token"
	"golang.org/x/exp/slices"
	"html/template"
	"os"
	"path/filepath"
	"strings"
)

var (
	t           = flag.String("type", "http", "注册的类型：默认是http，可选grpc")
	packagePath = flag.String("packagePath", "", "pb目录的package路径，如：fast/api/alipayoil")
	dirPath     = flag.String("dirPath", "", "pb目录路径，如果是generate运行，则它是相对于//go:generate文件的路径，如果是命令行直接运行，则相对目录为运行时的目录，如：../../../api/alipayoil")
	debug       = flag.Bool("debug", false, "pb的文件目录")
	outputFile  = flag.String("outputFile", "", "输出文件的目录，默认为当前目录的register_{type}_server_gen.go")
)

type packageInfo struct {
	Dir            string
	Name           string
	ImportCode     string
	InterfaceNames []string
	PackagePath    string
}

var packageServicesMap = make(map[string]*packageInfo)

func main() {
	flag.Parse()
	if *packagePath == "" {
		color.Red("packagePath 不能为空，请填写要生成的pb的目录（子目录也会自动生成）")
		return
	}
	*packagePath = strings.TrimRight(*packagePath, "/")
	if *dirPath == "" {
		color.Red("dirPath 不能为空，pb目录路径，如果是generate运行，则它是相对于//go:generate文件的路径，如果是命令行直接运行，则相对目录为运行时的目录，如：../../../api/alipayoil")
		return
	}
	*dirPath = strings.TrimRight(*dirPath, "/")
	if !slices.Contains([]string{"http", "grpc"}, *t) {
		color.Red("type 只能是http或grpc")
		return
	}
	var err error
	if *outputFile == "" {
		*outputFile, err = os.Getwd()
		if err != nil {
			color.Red("获取当前目录失败：%s", err)
			return
		}
		*outputFile += "/register_" + *t + "_server_gen.go"
	}

	//test
	//*pbPath = "cmd/registerserver/testdata/"

	fi, err := os.Stat(*dirPath)
	if err != nil {
		color.Red("获取文件信息失败：%s", *dirPath, err.Error())
		return
	}
	fileSuffix := fmt.Sprintf("_%s.pb.go", *t)
	if !fi.IsDir() {
		color.Red("%s不是一个目录", *dirPath)
		return
	}
	//遍历目录
	err = filepath.WalkDir(*dirPath, func(path string, d os.DirEntry, err error) error {
		if path == *dirPath {
			// 排除自身
			return nil
		}
		if d.IsDir() || !strings.HasSuffix(path, fileSuffix) {
			// 排除不相关文件
			return nil
		}
		subPath := strings.TrimPrefix(filepath.Dir(path), *dirPath)
		subPath = "/" + strings.TrimPrefix(subPath, "/")
		fullPackage := *packagePath + subPath

		err = parseServerInterface(path, fullPackage, *t)
		if err != nil {
			color.Red("解析代码文件ast%s失败：%s", path, err.Error())
			return err
		}
		return nil
	})
	if err != nil {
		color.Red("遍历目录时发生错误: %v\n", err)
		return
	}
	err = generate(*t)
	if err != nil {
		color.Red("解析代码文件ast%s失败：%s", *dirPath, err.Error())
		return
	}
	color.Green("生成成功！")
}

func parseServerInterface(filePath, fullPackage, serverType string) error {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	myPackage, isExistPackage := packageServicesMap[fullPackage]
	if !isExistPackage {
		myPackage = &packageInfo{
			Dir:            filepath.Dir(filePath),
			Name:           "",
			InterfaceNames: make([]string, 0, 10),
			PackagePath:    fullPackage,
		}
		packageServicesMap[fullPackage] = myPackage
	}

	serviceSuffix := fmt.Sprintf("%sServer", strings.ToUpper(serverType))
	ast.Inspect(file, func(node ast.Node) bool {
		if sf, ok := node.(*ast.File); ok && !isExistPackage {
			myPackage.Name = sf.Name.Name
		} else if st, ok := node.(*ast.TypeSpec); ok && st.Type != nil {
			if _, ok = st.Type.(*ast.InterfaceType); ok && strings.HasSuffix(st.Name.Name, serviceSuffix) {
				packageServicesMap[fullPackage].InterfaceNames = append(packageServicesMap[fullPackage].InterfaceNames, st.Name.Name)
			}
		}
		return true
	})
	if !strings.HasSuffix(myPackage.PackagePath, myPackage.Name) {
		myPackage.ImportCode = fmt.Sprintf(`%s "%s"`, myPackage.Name, myPackage.PackagePath)
	} else {
		myPackage.ImportCode = fmt.Sprintf(`"%s"`, myPackage.PackagePath)
	}
	return nil
}

func generate(serviceType string) error {
	// 打开生成文件
	var err error
	f := os.Stdout
	if !*debug {
		f, err = os.OpenFile(*outputFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
		if err != nil {
			return err
		}
	}

	// 渲染模板
	tmpl, err := template.New("code").Funcs(template.FuncMap{
		"html": func(s string) string {
			return s
		},
	}).Parse(codeTmpl)
	if err != nil {
		return err
	}
	err = tmpl.Execute(f, struct {
		PackageServicesMap map[string]*packageInfo
		Type               string
		TypeUpper          string
		PackageName        string
	}{
		PackageServicesMap: packageServicesMap,
		Type:               serviceType,
		TypeUpper:          strings.ToUpper(serviceType),
		PackageName:        strings.ToLower(filepath.Base(filepath.Dir(*outputFile))),
	})
	if err != nil {
		return err
	}
	return nil
}

var codeTmpl = `// Code generated by registerserver. DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/go-kratos/kratos/v2/transport/{{.Type}}"{{range $element :=.PackageServicesMap}}
	{{$element.ImportCode | html}}{{end}}
)

type {{.TypeUpper}}ServiceRegister struct {
}

// New{{.TypeUpper}}ServiceRegister 构建实例，需要交由wire管理依赖
func New{{.TypeUpper}}ServiceRegister(
	srv *http.Server,{{range $element :=.PackageServicesMap}}{{range $element2 := $element.InterfaceNames}}
	{{$element.Name}}{{$element2}} {{$element.Name}}.{{$element2}},{{end}}{{end}}
) *{{.TypeUpper}}ServiceRegister {
	{{range $element :=.PackageServicesMap}}{{range $element2 := $element.InterfaceNames}}
	{{$element.Name}}.Register{{$element2}}(srv, {{$element.Name}}{{$element2}}){{end}}{{end}}

	return &{{.TypeUpper}}ServiceRegister{}
}
`
